{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GiphyFetch = void 0;\n/* eslint-disable no-dupe-class-members */\n\nvar js_util_1 = require(\"@giphy/js-util\");\n\nvar qs_1 = __importDefault(require(\"qs\"));\n\nvar gif_1 = require(\"./normalize/gif\");\n\nvar request_1 = __importDefault(require(\"./request\"));\n\nvar getType = function (options) {\n  return options && options.type ? options.type : 'gifs';\n};\n/**\n * @class GiphyFetch\n * @param {string} apiKey\n */\n\n\nvar GiphyFetch =\n/** @class */\nfunction () {\n  function GiphyFetch(apiKey) {\n    var _this = this;\n    /**\n     * @hidden\n     */\n\n\n    this.getQS = function (options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      return qs_1.default.stringify(__assign(__assign({}, options), {\n        api_key: _this.apiKey,\n        pingback_id: js_util_1.getPingbackId()\n      }));\n    };\n\n    this.apiKey = apiKey;\n  }\n  /**\n   * A list of categories\n   *\n   * @param {CategoriesOptions} [options]\n   * @returns {Promise<CategoriesResult>}\n   */\n\n\n  GiphyFetch.prototype.categories = function (options) {\n    return request_1.default(\"gifs/categories?\" + this.getQS(options));\n  };\n  /**\n   * Get a single gif by a id\n   * @param {string} id\n   * @returns {Promise<GifsResult>}\n   **/\n\n\n  GiphyFetch.prototype.gif = function (id) {\n    return request_1.default(\"gifs/\" + id + \"?\" + this.getQS(), gif_1.normalizeGif);\n  };\n\n  GiphyFetch.prototype.gifs = function (arg1, arg2) {\n    if (Array.isArray(arg1)) {\n      return request_1.default(\"gifs?\" + this.getQS({\n        ids: arg1.join(',')\n      }), gif_1.normalizeGifs);\n    }\n\n    return request_1.default(\"gifs/categories/\" + arg1 + \"/\" + arg2 + \"?\" + this.getQS(), gif_1.normalizeGifs);\n  };\n\n  GiphyFetch.prototype.emoji = function (options) {\n    return request_1.default(\"emoji?\" + this.getQS(options), gif_1.normalizeGifs);\n  };\n\n  GiphyFetch.prototype.animate = function (text, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var qsParams = this.getQS(__assign(__assign({}, options), {\n      m: text\n    }));\n    return request_1.default(\"text/animate?\" + qsParams, gif_1.normalizeGifs);\n  };\n  /**\n   * @param term: string The term you're searching for\n   * @param options: SearchOptions\n   * @returns {Promise<GifsResult>}\n   **/\n\n\n  GiphyFetch.prototype.search = function (term, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var q = options.channel ? \"@\" + options.channel + \" \" + term : term;\n    var excludeDynamicResults;\n\n    if (options.type === 'text') {\n      excludeDynamicResults = true;\n    }\n\n    var qsParams = this.getQS(__assign(__assign({}, options), {\n      q: q,\n      excludeDynamicResults: excludeDynamicResults\n    }));\n    return request_1.default(getType(options) + \"/search?\" + qsParams, gif_1.normalizeGifs);\n  };\n  /**\n   * Get a list of subcategories\n   * @param {string} category\n   * @param {SubcategoriesOptions} options\n   * @returns {Promise<CategoriesResult>}\n   */\n\n\n  GiphyFetch.prototype.subcategories = function (category, options) {\n    return request_1.default(\"gifs/categories/\" + category + \"?\" + this.getQS(options));\n  };\n  /**\n   * Get trending gifs\n   *\n   * @param {TrendingOptions} options\n   * @returns {Promise<GifsResult>}\n   */\n\n\n  GiphyFetch.prototype.trending = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return request_1.default(getType(options) + \"/trending?\" + this.getQS(options), gif_1.normalizeGifs);\n  };\n  /**\n   * Get a random gif\n   * @param {RandomOptions}\n   * @returns {Promise<GifResult>}\n   **/\n\n\n  GiphyFetch.prototype.random = function (options) {\n    return request_1.default(getType(options) + \"/random?\" + this.getQS(options), gif_1.normalizeGif, true);\n  };\n  /**\n   * Get related gifs by a id\n   * @param {string} id\n   * @param {SubcategoriesOptions} options\n   * @returns {Promise<GifsResult>}\n   **/\n\n\n  GiphyFetch.prototype.related = function (id, options) {\n    return request_1.default(((options === null || options === void 0 ? void 0 : options.type) === 'stickers' ? 'stickers' : 'gifs') + \"/related?\" + this.getQS(__assign({\n      gif_id: id\n    }, options)), gif_1.normalizeGifs);\n  };\n\n  return GiphyFetch;\n}();\n\nexports.GiphyFetch = GiphyFetch;\nexports.default = GiphyFetch;","map":{"version":3,"mappings":"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","names":["getType","options","type","apiKey","qs_1","stringify","__assign","api_key","_this","pingback_id","js_util_1","GiphyFetch","request_1","getQS","id","gif_1","arg1","arg2","Array","isArray","ids","join","text","qsParams","m","term","q","channel","excludeDynamicResults","category","gif_id","exports"],"sources":["/home/simo/programming/web/projects/search-gifs/node_modules/@giphy/js-fetch-api/src/api.ts"],"sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport { getPingbackId } from '@giphy/js-util'\nimport qs from 'qs'\nimport { normalizeGif, normalizeGifs } from './normalize/gif'\nimport {\n    CategoriesOptions,\n    MediaType,\n    PaginationOptions,\n    RandomOptions,\n    RelatedOptions,\n    SearchOptions,\n    SubcategoriesOptions,\n    TrendingOptions,\n    TypeOption,\n} from './option-types'\nimport request from './request'\nimport { CategoriesResult, GifResult, GifsResult } from './result-types'\n\nconst getType = (options?: TypeOption): MediaType => (options && options.type ? options.type : 'gifs')\n/**\n * @class GiphyFetch\n * @param {string} apiKey\n */\nexport class GiphyFetch {\n    constructor(apiKey: string) {\n        this.apiKey = apiKey\n    }\n\n    /**\n     * @hidden\n     */\n    private apiKey: string\n    /**\n     * @hidden\n     */\n    private getQS = (options: any = {}) => {\n        return qs.stringify({ ...options, api_key: this.apiKey, pingback_id: getPingbackId() })\n    }\n\n    /**\n     * A list of categories\n     *\n     * @param {CategoriesOptions} [options]\n     * @returns {Promise<CategoriesResult>}\n     */\n    categories(options?: CategoriesOptions): Promise<CategoriesResult> {\n        return request(`gifs/categories?${this.getQS(options)}`) as Promise<CategoriesResult>\n    }\n\n    /**\n     * Get a single gif by a id\n     * @param {string} id\n     * @returns {Promise<GifsResult>}\n     **/\n    gif(id: string): Promise<GifResult> {\n        return request(`gifs/${id}?${this.getQS()}`, normalizeGif) as Promise<GifResult>\n    }\n\n    /**\n     *\n     * @function\n     * Get gifs by an array of ids\n     * @param {string[]} ids\n     *\n     * @function\n     * Get gifs by category and subcategory\n     * @param {string} category\n     * @param {string} subcategory\n     * @returns {Promise<GifsResult>}\n     **/\n    gifs(ids: string[]): Promise<GifsResult>\n    gifs(category: string, subcategory: string): Promise<GifsResult>\n    gifs(arg1: any, arg2?: string): Promise<GifsResult> {\n        if (Array.isArray(arg1)) {\n            return request(`gifs?${this.getQS({ ids: arg1.join(',') })}`, normalizeGifs) as Promise<GifsResult>\n        }\n        return request(`gifs/categories/${arg1}/${arg2}?${this.getQS()}`, normalizeGifs) as Promise<GifsResult>\n    }\n\n    emoji(options?: PaginationOptions): Promise<GifsResult> {\n        return request(`emoji?${this.getQS(options)}`, normalizeGifs) as Promise<GifsResult>\n    }\n\n    animate(text: string, options: PaginationOptions = {}): Promise<GifsResult> {\n        const qsParams = this.getQS({ ...options, m: text })\n        return request(`text/animate?${qsParams}`, normalizeGifs) as Promise<GifsResult>\n    }\n\n    /**\n     * @param term: string The term you're searching for\n     * @param options: SearchOptions\n     * @returns {Promise<GifsResult>}\n     **/\n    search(term: string, options: SearchOptions = {}): Promise<GifsResult> {\n        const q = options.channel ? `@${options.channel} ${term}` : term\n        let excludeDynamicResults\n        if (options.type === 'text') {\n            excludeDynamicResults = true\n        }\n        const qsParams = this.getQS({ ...options, q, excludeDynamicResults })\n        return request(`${getType(options)}/search?${qsParams}`, normalizeGifs) as Promise<GifsResult>\n    }\n\n    /**\n     * Get a list of subcategories\n     * @param {string} category\n     * @param {SubcategoriesOptions} options\n     * @returns {Promise<CategoriesResult>}\n     */\n    subcategories(category: string, options?: SubcategoriesOptions): Promise<CategoriesResult> {\n        return request(`gifs/categories/${category}?${this.getQS(options)}`) as Promise<CategoriesResult>\n    }\n\n    /**\n     * Get trending gifs\n     *\n     * @param {TrendingOptions} options\n     * @returns {Promise<GifsResult>}\n     */\n    trending(options: TrendingOptions = {}): Promise<GifsResult> {\n        return request(`${getType(options)}/trending?${this.getQS(options)}`, normalizeGifs) as Promise<GifsResult>\n    }\n\n    /**\n     * Get a random gif\n     * @param {RandomOptions}\n     * @returns {Promise<GifResult>}\n     **/\n    random(options?: RandomOptions): Promise<GifResult> {\n        return request(`${getType(options)}/random?${this.getQS(options)}`, normalizeGif, true) as Promise<GifResult>\n    }\n\n    /**\n     * Get related gifs by a id\n     * @param {string} id\n     * @param {SubcategoriesOptions} options\n     * @returns {Promise<GifsResult>}\n     **/\n    related(id: string, options?: RelatedOptions): Promise<GifsResult> {\n        return request(\n            `${options?.type === 'stickers' ? 'stickers' : 'gifs'}/related?${this.getQS({ gif_id: id, ...options })}`,\n            normalizeGifs\n        ) as Promise<GifsResult>\n    }\n}\nexport default GiphyFetch\n"]},"metadata":{},"sourceType":"script"}