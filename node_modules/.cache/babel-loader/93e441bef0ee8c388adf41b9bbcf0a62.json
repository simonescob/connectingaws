{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SearchContext = void 0;\n\nvar js_fetch_api_1 = require(\"@giphy/js-fetch-api\");\n\nvar emotion_theming_1 = require(\"emotion-theming\");\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar pingback_context_manager_1 = __importDefault(require(\"../pingback-context-manager\"));\n\nvar theme_1 = require(\"./theme\");\n\nexports.SearchContext = react_1.createContext({});\nvar emptyGifsResult = {\n  data: [],\n  pagination: {\n    total_count: 0,\n    count: 0,\n    offset: 0\n  },\n  meta: {\n    status: 200,\n    msg: 'OK',\n    response_id: ''\n  }\n};\n\nvar SearchContextManager = function (_a) {\n  var _b, _c;\n\n  var children = _a.children,\n      _d = _a.options,\n      options = _d === void 0 ? {} : _d,\n      apiKey = _a.apiKey,\n      theme = _a.theme,\n      _e = _a.initialTerm,\n      initialTerm = _e === void 0 ? '' : _e,\n      initialChannel = _a.initialChannel,\n      _f = _a.shouldDefaultToTrending,\n      shouldDefaultToTrending = _f === void 0 ? true : _f;\n  var gf = react_1.useMemo(function () {\n    return new js_fetch_api_1.GiphyFetch(apiKey);\n  }, [apiKey]); // the search term\n\n  var _g = react_1.useState(initialTerm),\n      term = _g[0],\n      setTerm = _g[1];\n\n  var _h = react_1.useState(false),\n      isFetching = _h[0],\n      setIsFetching = _h[1]; // a user name search\n\n\n  var channelSearch = '';\n\n  if (term && term.indexOf('@') === 0) {\n    channelSearch = term.slice(1).split(' ')[0];\n  } // active channel we're searching and displaying in the search bar\n\n\n  var _j = react_1.useState(initialChannel),\n      activeChannel = _j[0],\n      _setActiveChannel = _j[1];\n\n  var setActiveChannel = react_1.useCallback(function (activeChannel) {\n    _setActiveChannel(activeChannel);\n\n    setTerm(''); // TODO: clear this here?\n  }, []); // fetched list of trending search terms\n\n  var _k = react_1.useState([]),\n      trendingSearches = _k[0],\n      setTrendingSearches = _k[1]; // do a search for a term and optionally a channel\n\n\n  var setSearch = react_1.useCallback(function (term) {\n    return setTerm(term);\n  }, []);\n  var searchKey = [term, options.type, channelSearch, ((_b = activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.user) === null || _b === void 0 ? void 0 : _b.username) || ''].filter(function (val) {\n    return !!val;\n  }).join(' / '); // search fetch\n\n  var fetchGifs = react_1.useCallback(function (offset) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var result;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            setIsFetching(true);\n            result = emptyGifsResult;\n            if (!term) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , gf.search(term, __assign(__assign({}, options), {\n              offset: offset,\n              channel: (_a = activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.user) === null || _a === void 0 ? void 0 : _a.username\n            }))];\n\n          case 1:\n            result = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!shouldDefaultToTrending) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , gf.trending(__assign(__assign({}, options), {\n              offset: offset\n            }))];\n\n          case 3:\n            result = _b.sent();\n            _b.label = 4;\n\n          case 4:\n            setIsFetching(false);\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  }, [(_c = activeChannel === null || activeChannel === void 0 ? void 0 : activeChannel.user) === null || _c === void 0 ? void 0 : _c.username, gf, options, term, shouldDefaultToTrending]);\n  var fetchAnimatedText = react_1.useCallback(function (offset) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var limit, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            limit = options.limit || 50;\n            return [4\n            /*yield*/\n            , gf.animate(term, {\n              offset: offset,\n              limit: limit\n            })];\n\n          case 1:\n            result = _a.sent();\n\n            if (!result.pagination) {\n              result.pagination = {\n                count: limit,\n                total_count: limit,\n                offset: offset\n              };\n            }\n\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  }, [gf, options.limit, term]);\n  var fetchChannelSearch = react_1.useCallback(function (offset) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var result, data;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , fetch(js_fetch_api_1.serverUrl + \"channels/search?q=\" + encodeURIComponent(channelSearch) + \"&offset=\" + offset + \"&api_key=\" + apiKey)];\n\n          case 1:\n            result = _a.sent();\n            return [4\n            /*yield*/\n            , result.json()];\n\n          case 2:\n            data = _a.sent().data;\n            return [2\n            /*return*/\n            , data];\n        }\n      });\n    });\n  }, [apiKey, channelSearch]);\n  react_1.useEffect(function () {\n    var fetchTrendingSearches = function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var result, data;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , fetch(js_fetch_api_1.serverUrl + \"trending/searches?api_key=\" + apiKey)];\n\n            case 1:\n              result = _a.sent();\n              return [4\n              /*yield*/\n              , result.json()];\n\n            case 2:\n              data = _a.sent().data;\n              setTrendingSearches(data || []);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    fetchTrendingSearches();\n  }, [apiKey]);\n  return react_1.default.createElement(exports.SearchContext.Provider, {\n    value: {\n      activeChannel: activeChannel,\n      setActiveChannel: setActiveChannel,\n      fetchChannelSearch: fetchChannelSearch,\n      term: term,\n      channelSearch: channelSearch,\n      trendingSearches: trendingSearches,\n      setSearch: setSearch,\n      fetchGifs: fetchGifs,\n      fetchAnimatedText: fetchAnimatedText,\n      searchKey: searchKey,\n      isFetching: isFetching\n    }\n  }, react_1.default.createElement(emotion_theming_1.ThemeProvider, {\n    theme: theme_1.initTheme(theme)\n  }, react_1.default.createElement(pingback_context_manager_1.default, {\n    attributes: {\n      layout_type: 'SEARCH'\n    }\n  }, children)));\n};\n\nexports.default = SearchContextManager;","map":{"version":3,"mappings":"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","names":["exports","react_1","emptyGifsResult","data","pagination","total_count","count","offset","meta","status","msg","response_id","SearchContextManager","_a","children","_d","options","apiKey","theme","_e","initialTerm","initialChannel","_f","shouldDefaultToTrending","gf","js_fetch_api_1","term","setTerm","isFetching","setIsFetching","channelSearch","indexOf","slice","split","activeChannel","_setActiveChannel","setActiveChannel","trendingSearches","setTrendingSearches","setSearch","searchKey","type","user","_b","username","filter","val","join","fetchGifs","result","search","__assign","channel","trending","_c","fetchAnimatedText","limit","animate","fetchChannelSearch","fetch","encodeURIComponent","json","fetchTrendingSearches","Provider","value","emotion_theming_1","theme_1","pingback_context_manager_1","attributes","layout_type"],"sources":["/home/simo/programming/web/projects/search-gifs/node_modules/@giphy/react-components/src/components/search-bar/context.tsx"],"sourcesContent":["import { GifsResult, GiphyFetch, SearchOptions, serverUrl } from '@giphy/js-fetch-api'\nimport { IChannel } from '@giphy/js-types'\nimport { ThemeProvider } from 'emotion-theming'\nimport React, { createContext, ReactNode, useCallback, useEffect, useMemo, useState } from 'react'\nimport PingbackContextManager from '../pingback-context-manager'\nimport { initTheme, SearchTheme } from './theme'\n\nexport type SearchContextProps = {\n    setSearch: (searchTerm: string) => void\n    term: string\n    channelSearch: string\n    activeChannel: IChannel | undefined\n    setActiveChannel: (channel: IChannel | undefined) => void\n    fetchGifs: (offset: number) => Promise<GifsResult>\n    fetchAnimatedText: (offset: number) => Promise<GifsResult>\n    fetchChannelSearch: (offset: number) => Promise<IChannel[]>\n    isFetching: boolean\n    trendingSearches: string[]\n    searchKey: string\n}\n\nexport const SearchContext = createContext({} as SearchContextProps)\n\ntype Props = {\n    children: ReactNode\n    options?: SearchOptions\n    apiKey: string\n    theme?: Partial<SearchTheme>\n    initialTerm?: string\n    initialChannel?: IChannel\n    shouldDefaultToTrending?: boolean\n}\n\nconst emptyGifsResult = {\n    data: [],\n    pagination: { total_count: 0, count: 0, offset: 0 },\n    meta: { status: 200, msg: 'OK', response_id: '' },\n}\nconst SearchContextManager = ({\n    children,\n    options = {},\n    apiKey,\n    theme,\n    initialTerm = '',\n    initialChannel,\n    shouldDefaultToTrending = true,\n}: Props) => {\n    const gf = useMemo(() => new GiphyFetch(apiKey), [apiKey])\n\n    // the search term\n    const [term, setTerm] = useState<string>(initialTerm)\n\n    const [isFetching, setIsFetching] = useState(false)\n\n    // a user name search\n    let channelSearch = ''\n\n    if (term && term.indexOf('@') === 0) {\n        channelSearch = term.slice(1).split(' ')[0]\n    }\n\n    // active channel we're searching and displaying in the search bar\n    const [activeChannel, _setActiveChannel] = useState<IChannel | undefined>(initialChannel)\n\n    const setActiveChannel = useCallback((activeChannel: IChannel | undefined) => {\n        _setActiveChannel(activeChannel)\n        setTerm('') // TODO: clear this here?\n    }, [])\n\n    // fetched list of trending search terms\n    const [trendingSearches, setTrendingSearches] = useState<string[]>([])\n    // do a search for a term and optionally a channel\n    const setSearch = useCallback((term: string) => setTerm(term), [])\n\n    const searchKey = [term, options.type, channelSearch, activeChannel?.user?.username || '']\n        .filter((val) => !!val)\n        .join(' / ')\n\n    // search fetch\n    const fetchGifs = useCallback(\n        async (offset: number) => {\n            setIsFetching(true)\n            let result: GifsResult = emptyGifsResult\n            if (term) {\n                result = await gf.search(term, {\n                    ...options,\n                    offset,\n                    channel: activeChannel?.user?.username,\n                })\n            } else if (shouldDefaultToTrending) {\n                result = await gf.trending({ ...options, offset })\n            }\n            setIsFetching(false)\n            return result\n        },\n        [activeChannel?.user?.username, gf, options, term, shouldDefaultToTrending]\n    )\n\n    const fetchAnimatedText = useCallback(\n        async (offset: number) => {\n            const limit = options.limit || 50\n            const result = await gf.animate(term, { offset, limit })\n            if (!result.pagination) {\n                result.pagination = { count: limit, total_count: limit, offset }\n            }\n            return result\n        },\n        [gf, options.limit, term]\n    )\n\n    const fetchChannelSearch = useCallback(\n        async (offset: number) => {\n            const result = await fetch(\n                `${serverUrl}channels/search?q=${encodeURIComponent(channelSearch)}&offset=${offset}&api_key=${apiKey}`\n            )\n            const { data } = await result.json()\n            return data as IChannel[]\n        },\n        [apiKey, channelSearch]\n    )\n    useEffect(() => {\n        const fetchTrendingSearches = async () => {\n            const result = await fetch(`${serverUrl}trending/searches?api_key=${apiKey}`)\n            const { data } = await result.json()\n            setTrendingSearches(data || [])\n        }\n        fetchTrendingSearches()\n    }, [apiKey])\n    return (\n        <SearchContext.Provider\n            value={{\n                activeChannel,\n                setActiveChannel,\n                fetchChannelSearch,\n                term,\n                channelSearch,\n                trendingSearches,\n                setSearch,\n                fetchGifs,\n                fetchAnimatedText,\n                searchKey,\n                isFetching,\n            }}\n        >\n            <ThemeProvider theme={initTheme(theme)}>\n                <PingbackContextManager attributes={{ layout_type: 'SEARCH' }}>{children}</PingbackContextManager>\n            </ThemeProvider>\n        </SearchContext.Provider>\n    )\n}\n\nexport default SearchContextManager\n"]},"metadata":{},"sourceType":"script"}