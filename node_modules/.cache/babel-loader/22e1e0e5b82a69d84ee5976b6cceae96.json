{"ast":null,"code":"\"use strict\";\n\nvar __makeTemplateObject = this && this.__makeTemplateObject || function (cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n};\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getColor = exports.GRID_COLORS = void 0;\n\nvar core_1 = require(\"@emotion/core\");\n\nvar styled_1 = __importDefault(require(\"@emotion/styled\"));\n\nvar js_brand_1 = require(\"@giphy/js-brand\");\n\nvar js_util_1 = require(\"@giphy/js-util\");\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar pingback = __importStar(require(\"../util/pingback\"));\n\nvar overlay_1 = __importDefault(require(\"./attribution/overlay\"));\n\nvar verified_badge_1 = __importDefault(require(\"./attribution/verified-badge\"));\n\nvar pingback_context_manager_1 = require(\"./pingback-context-manager\");\n\nvar GifContainer = styled_1.default.div(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"\\n    display: block;\\n    &:focus {\\n        outline: unset;\\n    }\\n    \", \"\\n    img {\\n        display: block;\\n    }\\n    .\", \" {\\n        g {\\n            fill: white;\\n        }\\n    }\\n    .\", \" {\\n        opacity: 0;\\n    }\\n\"], [\"\\n    display: block;\\n    &:focus {\\n        outline: unset;\\n    }\\n    \", \"\\n    img {\\n        display: block;\\n    }\\n    .\", \" {\\n        g {\\n            fill: white;\\n        }\\n    }\\n    .\", \" {\\n        opacity: 0;\\n    }\\n\"])), function (props) {\n  return props.borderRadius && core_1.css(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n            border-radius: \", \"px;\\n            overflow: hidden;\\n        \"], [\"\\n            border-radius: \", \"px;\\n            overflow: hidden;\\n        \"])), props.borderRadius);\n}, verified_badge_1.default.className, verified_badge_1.default.checkMarkClassName);\nexports.GRID_COLORS = [js_brand_1.giphyBlue, js_brand_1.giphyGreen, js_brand_1.giphyPurple, js_brand_1.giphyRed, js_brand_1.giphyYellow];\n\nvar getColor = function () {\n  return exports.GRID_COLORS[Math.round(Math.random() * (exports.GRID_COLORS.length - 1))];\n};\n\nexports.getColor = getColor;\nvar hoverTimeoutDelay = 200;\n\nvar Container = function (props) {\n  return react_1.default.createElement(GifContainer, __assign({\n    as: props.href ? 'a' : 'div'\n  }, props));\n};\n\nvar placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // used to detect if we're on the server or client\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nvar noop = function () {};\n\nvar Gif = function (_a) {\n  var gif = _a.gif,\n      width = _a.width,\n      forcedHeight = _a.height,\n      _b = _a.onGifRightClick,\n      onGifRightClick = _b === void 0 ? noop : _b,\n      _c = _a.className,\n      className = _c === void 0 ? '' : _c,\n      _d = _a.onGifClick,\n      onGifClick = _d === void 0 ? noop : _d,\n      _e = _a.onGifSeen,\n      onGifSeen = _e === void 0 ? noop : _e,\n      _f = _a.onGifVisible,\n      onGifVisible = _f === void 0 ? noop : _f,\n      _g = _a.user,\n      user = _g === void 0 ? {} : _g,\n      backgroundColor = _a.backgroundColor,\n      overlay = _a.overlay,\n      _h = _a.hideAttribution,\n      hideAttribution = _h === void 0 ? false : _h,\n      _j = _a.noLink,\n      noLink = _j === void 0 ? false : _j,\n      _k = _a.borderRadius,\n      borderRadius = _k === void 0 ? 4 : _k,\n      style = _a.style,\n      tabIndex = _a.tabIndex; // only fire seen once per gif id\n\n  var _l = react_1.useState(false),\n      hasFiredSeen = _l[0],\n      setHasFiredSeen = _l[1]; // hovered is for the gif overlay\n\n\n  var _m = react_1.useState(false),\n      isHovered = _m[0],\n      setHovered = _m[1]; // only show the gif if it's on the screen\n  // if we can't use the dom (SSR), then we show the gif by default\n\n\n  var _o = react_1.useState(!canUseDOM),\n      showGif = _o[0],\n      setShowGif = _o[1]; // classname to target animations on image load\n\n\n  var _p = react_1.useState(''),\n      loadedClassname = _p[0],\n      setLoadedClassName = _p[1]; // the background color shouldn't change unless it comes from a prop or we have a sticker\n\n\n  var defaultBgColor = react_1.useRef(exports.getColor()); // the a tag the media is rendered into\n\n  var container = react_1.useRef(null); // to play it safe when using SSR, we check image.complete after mount\n\n  var image = react_1.useRef(null); // intersection observer with no threshold\n\n  var showGifObserver = react_1.useRef(); // intersection observer with a threshold of 1 (full element is on screen)\n\n  var fullGifObserver = react_1.useRef(); // fire hover pingback after this timeout\n\n  var hoverTimeout = react_1.useRef(); // fire onseen ref (changes per gif, so need a ref)\n\n  var sendOnSeen = react_1.useRef(noop); // custom pingback\n\n  var attributes = react_1.useContext(pingback_context_manager_1.PingbackContext).attributes; // user's overlay\n\n  var Overlay = overlay;\n\n  if (!Overlay && !hideAttribution) {\n    // no user overlay, and no force hide of the attribution\n    Overlay = overlay_1.default;\n  }\n\n  var onMouseOver = function (e) {\n    clearTimeout(hoverTimeout.current);\n    e.persist();\n    setHovered(true);\n    hoverTimeout.current = window.setTimeout(function () {\n      pingback.onGifHover(gif, user === null || user === void 0 ? void 0 : user.id, e.target, attributes);\n    }, hoverTimeoutDelay);\n  };\n\n  var onMouseLeave = function () {\n    clearTimeout(hoverTimeout.current);\n    setHovered(false);\n  };\n\n  var onClick = function (e) {\n    // fire pingback\n    pingback.onGifClick(gif, user === null || user === void 0 ? void 0 : user.id, e.target, attributes);\n    onGifClick(gif, e);\n  }; // using a ref in case `gif` changes\n\n\n  sendOnSeen.current = function (entry) {\n    // flag so we don't observe any more\n    setHasFiredSeen(true);\n    js_util_1.Logger.debug(\"GIF \" + gif.id + \" seen. \" + gif.title); // fire pingback\n\n    pingback.onGifSeen(gif, user === null || user === void 0 ? void 0 : user.id, entry.boundingClientRect, attributes); // fire custom onGifSeen\n\n    onGifSeen === null || onGifSeen === void 0 ? void 0 : onGifSeen(gif, entry.boundingClientRect); // disconnect\n\n    if (fullGifObserver.current) {\n      fullGifObserver.current.disconnect();\n    }\n  };\n\n  var watchGif = function () {\n    if (!fullGifObserver.current) {\n      fullGifObserver.current = new IntersectionObserver(function (_a) {\n        var entry = _a[0];\n\n        if (entry.isIntersecting) {\n          sendOnSeen.current(entry);\n        }\n      }, {\n        threshold: [0.99]\n      });\n    }\n\n    if (!hasFiredSeen && container.current && fullGifObserver.current) {\n      // observe img for full gif view\n      fullGifObserver.current.observe(container.current);\n    }\n  };\n\n  var onImageLoad = function (e) {\n    watchGif();\n    onGifVisible(gif, e); // gif is visible, perhaps just partially\n\n    setLoadedClassName(Gif.imgLoadedClassName);\n  };\n\n  react_1.useEffect(function () {\n    var _a, _b; // the id has changed, maybe the image has loaded\n\n\n    if ((_a = image.current) === null || _a === void 0 ? void 0 : _a.complete) {\n      watchGif();\n      onGifVisible(gif); // gif is visible, perhaps just partially\n    }\n\n    (_b = fullGifObserver.current) === null || _b === void 0 ? void 0 : _b.disconnect();\n    setHasFiredSeen(false); // We only want to fire this when gif id changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [gif.id]);\n  react_1.useEffect(function () {\n    showGifObserver.current = new IntersectionObserver(function (_a) {\n      var entry = _a[0];\n      var isIntersecting = entry.isIntersecting; // show the gif if the container is on the screen\n\n      setShowGif(isIntersecting); // remove the fullGifObserver if we go off the screen\n      // we may have already disconnected if the hasFiredSeen happened\n\n      if (!isIntersecting && fullGifObserver.current) {\n        fullGifObserver.current.disconnect();\n      }\n    });\n    showGifObserver.current.observe(container.current);\n    return function () {\n      if (showGifObserver.current) showGifObserver.current.disconnect();\n      if (fullGifObserver.current) fullGifObserver.current.disconnect();\n      if (hoverTimeout.current) clearTimeout(hoverTimeout.current);\n    };\n  }, []);\n  var height = forcedHeight || js_util_1.getGifHeight(gif, width);\n  var bestRendition = js_util_1.getBestRendition(gif.images, width, height);\n  var rendition = gif.images[bestRendition.renditionName];\n  var background = backgroundColor || ( // <- specified background prop\n  // sticker has black if no backgroundColor is specified\n  gif.is_sticker ? \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4AQMAAACSSKldAAAABlBMVEUhIiIWFhYoSqvJAAAAGElEQVQY02MAAv7///8PWxqIPwDZw5UGABtgwz2xhFKxAAAAAElFTkSuQmCC') 0 0\" : defaultBgColor.current);\n  return react_1.default.createElement(Container, {\n    href: noLink ? undefined : gif.url,\n    style: __assign({\n      width: width,\n      height: height\n    }, style),\n    borderRadius: borderRadius,\n    className: [Gif.className, className].join(' '),\n    onMouseOver: onMouseOver,\n    onMouseLeave: onMouseLeave,\n    onClick: onClick,\n    onContextMenu: function (e) {\n      return onGifRightClick(gif, e);\n    },\n    tabIndex: tabIndex\n  }, react_1.default.createElement(\"div\", {\n    style: {\n      width: width,\n      height: height,\n      position: 'relative'\n    },\n    ref: container\n  }, react_1.default.createElement(\"picture\", null, react_1.default.createElement(\"source\", {\n    type: \"image/webp\",\n    srcSet: rendition.webp\n  }), react_1.default.createElement(\"img\", {\n    ref: image,\n    suppressHydrationWarning: true,\n    className: [Gif.imgClassName, loadedClassname].join(' '),\n    src: showGif ? rendition.url : placeholder,\n    style: {\n      background: background\n    },\n    width: width,\n    height: height,\n    alt: js_util_1.getAltText(gif),\n    onLoad: showGif ? onImageLoad : function () {}\n  })), showGif ? Overlay && react_1.default.createElement(Overlay, {\n    gif: gif,\n    isHovered: isHovered,\n    width: width,\n    height: height\n  }) : null));\n};\n\nGif.className = 'giphy-gif';\nGif.imgClassName = 'giphy-gif-img';\nGif.imgLoadedClassName = 'giphy-img-loaded';\nexports.default = Gif;\nvar templateObject_1, templateObject_2;","map":{"version":3,"mappings":"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","names":["GifContainer","styled_1","div","templateObject_2","props","borderRadius","core_1","templateObject_1","verified_badge_1","className","checkMarkClassName","exports","js_brand_1","getColor","Math","round","random","length","hoverTimeoutDelay","Container","react_1","__assign","as","href","placeholder","canUseDOM","window","document","createElement","noop","Gif","_a","gif","width","forcedHeight","_b","onGifRightClick","_c","_d","onGifClick","_e","onGifSeen","_f","onGifVisible","_g","user","backgroundColor","overlay","_h","hideAttribution","_j","noLink","_k","style","tabIndex","hasFiredSeen","setHasFiredSeen","isHovered","setHovered","showGif","setShowGif","loadedClassname","setLoadedClassName","defaultBgColor","container","image","showGifObserver","fullGifObserver","hoverTimeout","sendOnSeen","pingback_context_manager_1","attributes","Overlay","overlay_1","onMouseOver","e","clearTimeout","current","persist","setTimeout","pingback","onGifHover","id","target","onMouseLeave","onClick","entry","js_util_1","debug","title","boundingClientRect","disconnect","watchGif","IntersectionObserver","isIntersecting","threshold","observe","onImageLoad","imgLoadedClassName","complete","height","bestRendition","images","rendition","renditionName","background","is_sticker","undefined","url","join","onContextMenu","position","ref","type","srcSet","webp","suppressHydrationWarning","imgClassName","src","alt","onLoad"],"sources":["/home/simo/programming/web/projects/search-gifs/node_modules/@giphy/react-components/src/components/gif.tsx"],"sourcesContent":["import { css } from '@emotion/core'\nimport styled from '@emotion/styled'\nimport { giphyBlue, giphyGreen, giphyPurple, giphyRed, giphyYellow } from '@giphy/js-brand'\nimport { IGif, ImageAllTypes, IUser } from '@giphy/js-types'\nimport { getAltText, getBestRendition, getGifHeight, Logger } from '@giphy/js-util'\nimport React, { ElementType, HTMLProps, SyntheticEvent, useContext, useEffect, useRef, useState } from 'react'\nimport * as pingback from '../util/pingback'\nimport AttributionOverlay from './attribution/overlay'\nimport VerifiedBadge from './attribution/verified-badge'\nimport { PingbackContext } from './pingback-context-manager'\nimport { GifOverlayProps } from './types'\n\nconst GifContainer = styled.div<{ borderRadius?: number }>`\n    display: block;\n    &:focus {\n        outline: unset;\n    }\n    ${(props) =>\n        props.borderRadius &&\n        css`\n            border-radius: ${props.borderRadius}px;\n            overflow: hidden;\n        `}\n    img {\n        display: block;\n    }\n    .${VerifiedBadge.className} {\n        g {\n            fill: white;\n        }\n    }\n    .${VerifiedBadge.checkMarkClassName} {\n        opacity: 0;\n    }\n`\n\nexport const GRID_COLORS = [giphyBlue, giphyGreen, giphyPurple, giphyRed, giphyYellow]\nexport const getColor = () => GRID_COLORS[Math.round(Math.random() * (GRID_COLORS.length - 1))]\n\nconst hoverTimeoutDelay = 200\n\ntype ContainerProps = HTMLProps<HTMLElement> & { href?: string; borderRadius: number }\nconst Container = (props: ContainerProps) => (\n    <GifContainer as={props.href ? 'a' : 'div'} {...(props as HTMLProps<HTMLDivElement>)} />\n)\n\nexport type EventProps = {\n    // fired every time the gif is show\n    onGifVisible?: (gif: IGif, e?: SyntheticEvent<HTMLElement, Event>) => void\n    // fired once after the gif loads and when it's completely in view\n    onGifSeen?: (gif: IGif, boundingClientRect: ClientRect | DOMRect) => void\n    // fired when the gif is clicked\n    onGifClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void\n    // fired when the gif is right clicked\n    onGifRightClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void\n}\n\ntype GifProps = {\n    gif: IGif\n    width: number\n    height?: number\n    backgroundColor?: string\n    className?: string\n    user?: Partial<IUser>\n    overlay?: ElementType<GifOverlayProps>\n    hideAttribution?: boolean\n    noLink?: boolean\n    borderRadius?: number\n    tabIndex?: number\n    style?: any\n}\n\ntype Props = GifProps & EventProps\n\nconst placeholder = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\n\n// used to detect if we're on the server or client\nconst canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement)\n\nconst noop = () => {}\n\nconst Gif = ({\n    gif,\n    width,\n    height: forcedHeight,\n    onGifRightClick = noop,\n    className = '',\n    onGifClick = noop,\n    onGifSeen = noop,\n    onGifVisible = noop,\n    user = {},\n    backgroundColor,\n    overlay,\n    hideAttribution = false,\n    noLink = false,\n    borderRadius = 4,\n    style,\n    tabIndex,\n}: Props) => {\n    // only fire seen once per gif id\n    const [hasFiredSeen, setHasFiredSeen] = useState(false)\n    // hovered is for the gif overlay\n    const [isHovered, setHovered] = useState(false)\n    // only show the gif if it's on the screen\n    // if we can't use the dom (SSR), then we show the gif by default\n    const [showGif, setShowGif] = useState(!canUseDOM)\n    // classname to target animations on image load\n    const [loadedClassname, setLoadedClassName] = useState('')\n    // the background color shouldn't change unless it comes from a prop or we have a sticker\n    const defaultBgColor = useRef(getColor())\n    // the a tag the media is rendered into\n    const container = useRef<HTMLDivElement | null>(null)\n    // to play it safe when using SSR, we check image.complete after mount\n    const image = useRef<HTMLImageElement | null>(null)\n    // intersection observer with no threshold\n    const showGifObserver = useRef<IntersectionObserver>()\n    // intersection observer with a threshold of 1 (full element is on screen)\n    const fullGifObserver = useRef<IntersectionObserver>()\n    // fire hover pingback after this timeout\n    const hoverTimeout = useRef<number>()\n    // fire onseen ref (changes per gif, so need a ref)\n    const sendOnSeen = useRef<(_: IntersectionObserverEntry) => void>(noop)\n    // custom pingback\n    const { attributes } = useContext(PingbackContext)\n    // user's overlay\n    let Overlay = overlay\n    if (!Overlay && !hideAttribution) {\n        // no user overlay, and no force hide of the attribution\n        Overlay = AttributionOverlay\n    }\n\n    const onMouseOver = (e: SyntheticEvent<HTMLElement, Event>) => {\n        clearTimeout(hoverTimeout.current!)\n        e.persist()\n        setHovered(true)\n        hoverTimeout.current = window.setTimeout(() => {\n            pingback.onGifHover(gif, user?.id, e.target as HTMLElement, attributes)\n        }, hoverTimeoutDelay)\n    }\n\n    const onMouseLeave = () => {\n        clearTimeout(hoverTimeout.current!)\n        setHovered(false)\n    }\n\n    const onClick = (e: SyntheticEvent<HTMLElement, Event>) => {\n        // fire pingback\n        pingback.onGifClick(gif, user?.id, e.target as HTMLElement, attributes)\n        onGifClick(gif, e)\n    }\n\n    // using a ref in case `gif` changes\n    sendOnSeen.current = (entry: IntersectionObserverEntry) => {\n        // flag so we don't observe any more\n        setHasFiredSeen(true)\n        Logger.debug(`GIF ${gif.id} seen. ${gif.title}`)\n        // fire pingback\n        pingback.onGifSeen(gif, user?.id, entry.boundingClientRect, attributes)\n        // fire custom onGifSeen\n        onGifSeen?.(gif, entry.boundingClientRect)\n        // disconnect\n        if (fullGifObserver.current) {\n            fullGifObserver.current.disconnect()\n        }\n    }\n    const watchGif = () => {\n        if (!fullGifObserver.current) {\n            fullGifObserver.current = new IntersectionObserver(\n                ([entry]: IntersectionObserverEntry[]) => {\n                    if (entry.isIntersecting) {\n                        sendOnSeen.current(entry)\n                    }\n                },\n                { threshold: [0.99] }\n            )\n        }\n        if (!hasFiredSeen && container.current && fullGifObserver.current) {\n            // observe img for full gif view\n            fullGifObserver.current.observe(container.current)\n        }\n    }\n\n    const onImageLoad = (e: SyntheticEvent<HTMLElement, Event>) => {\n        watchGif()\n        onGifVisible(gif, e) // gif is visible, perhaps just partially\n        setLoadedClassName(Gif.imgLoadedClassName)\n    }\n\n    useEffect(() => {\n        // the id has changed, maybe the image has loaded\n        if (image.current?.complete) {\n            watchGif()\n            onGifVisible(gif) // gif is visible, perhaps just partially\n        }\n        fullGifObserver.current?.disconnect()\n        setHasFiredSeen(false)\n        // We only want to fire this when gif id changes\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [gif.id])\n\n    useEffect(() => {\n        showGifObserver.current = new IntersectionObserver(([entry]: IntersectionObserverEntry[]) => {\n            const { isIntersecting } = entry\n            // show the gif if the container is on the screen\n            setShowGif(isIntersecting)\n            // remove the fullGifObserver if we go off the screen\n            // we may have already disconnected if the hasFiredSeen happened\n            if (!isIntersecting && fullGifObserver.current) {\n                fullGifObserver.current.disconnect()\n            }\n        })\n        showGifObserver.current.observe(container.current!)\n        return () => {\n            if (showGifObserver.current) showGifObserver.current.disconnect()\n            if (fullGifObserver.current) fullGifObserver.current.disconnect()\n            if (hoverTimeout.current) clearTimeout(hoverTimeout.current)\n        }\n    }, [])\n    const height = forcedHeight || getGifHeight(gif, width)\n    const bestRendition = getBestRendition(gif.images, width, height)\n    const rendition = gif.images[bestRendition.renditionName] as ImageAllTypes\n    const background =\n        backgroundColor || // <- specified background prop\n        // sticker has black if no backgroundColor is specified\n        (gif.is_sticker\n            ? `url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4AQMAAACSSKldAAAABlBMVEUhIiIWFhYoSqvJAAAAGElEQVQY02MAAv7///8PWxqIPwDZw5UGABtgwz2xhFKxAAAAAElFTkSuQmCC') 0 0`\n            : defaultBgColor.current)\n    return (\n        <Container\n            href={noLink ? undefined : gif.url}\n            style={{\n                width,\n                height,\n                ...style,\n            }}\n            borderRadius={borderRadius}\n            className={[Gif.className, className].join(' ')}\n            onMouseOver={onMouseOver}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onContextMenu={(e: SyntheticEvent<HTMLElement, Event>) => onGifRightClick(gif, e)}\n            tabIndex={tabIndex}\n        >\n            <div style={{ width, height, position: 'relative' }} ref={container}>\n                <picture>\n                    <source type=\"image/webp\" srcSet={rendition.webp} />\n                    <img\n                        ref={image}\n                        suppressHydrationWarning\n                        className={[Gif.imgClassName, loadedClassname].join(' ')}\n                        src={showGif ? rendition.url : placeholder}\n                        style={{ background }}\n                        width={width}\n                        height={height}\n                        alt={getAltText(gif)}\n                        onLoad={showGif ? onImageLoad : () => {}}\n                    />\n                </picture>\n                {showGif ? Overlay && <Overlay gif={gif} isHovered={isHovered} width={width} height={height} /> : null}\n            </div>\n        </Container>\n    )\n}\n\nGif.className = 'giphy-gif'\nGif.imgClassName = 'giphy-gif-img'\nGif.imgLoadedClassName = 'giphy-img-loaded'\n\nexport default Gif\n"]},"metadata":{},"sourceType":"script"}